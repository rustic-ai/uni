# Uni - Embedded Graph Database

> Uni is an embedded, object-store-backed graph database with OpenCypher queries, columnar analytics, and vector search. Use this reference when building Rust applications with Uni.

## Quick Start

```rust
use uni_db::Uni;

#[tokio::main]
async fn main() -> uni_db::Result<()> {
    // Create in-memory database
    let db = Uni::in_memory().build().await?;

    // Define schema
    db.schema()
        .label("Person")
        .property("name", DataType::String)
        .property("age", DataType::Int32)
        .done()
        .edge_type("KNOWS", &["Person"], &["Person"])
        .apply()
        .await?;

    // Create data
    db.execute("CREATE (:Person {name: 'Alice', age: 30})").await?;
    db.execute("CREATE (:Person {name: 'Bob', age: 25})").await?;
    db.execute("MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'}) CREATE (a)-[:KNOWS]->(b)").await?;

    // Query data
    let results = db.query("MATCH (p:Person) RETURN p.name, p.age ORDER BY p.age").await?;
    for row in results.rows() {
        println!("{}: {}", row.get::<String>("p.name")?, row.get::<i32>("p.age")?);
    }

    Ok(())
}
```

## Dependencies

```toml
[dependencies]
uni-db = "0.1"
tokio = { version = "1", features = ["full"] }
```

---

## Database Initialization

### Opening a Database

```rust
// In-memory (ephemeral)
let db = Uni::in_memory().build().await?;

// Temporary directory (auto-cleaned)
let db = Uni::temporary().build().await?;

// File-based persistence
let db = Uni::open("./my_graph").build().await?;

// Open existing only (fail if not exists)
let db = Uni::open_existing("./my_graph").build().await?;

// Create new only (fail if exists)
let db = Uni::create("./my_graph").build().await?;

// Object storage (S3/GCS/Azure)
let db = Uni::open("s3://bucket/path").build().await?;
let db = Uni::open("gs://bucket/path").build().await?;
let db = Uni::open("az://account/container").build().await?;

// Hybrid: local WAL + remote storage
let db = Uni::open("s3://bucket/path")
    .hybrid("./local_cache", "s3://bucket/path")
    .build().await?;

// With configuration
let db = Uni::open("./my_graph")
    .cache_size(1024 * 1024 * 1024)  // 1GB adjacency cache
    .parallelism(8)                   // Worker threads
    .schema_file("schema.json")       // Load schema from file
    .build().await?;

// Time-travel: open at specific snapshot
let db = Uni::open("./my_graph")
    .at_snapshot("snapshot_id")
    .build().await?;
```

### Cloud Storage Configuration

```rust
use uni_db::CloudStorageConfig;

// S3 from environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.)
let config = CloudStorageConfig::s3_from_env("my-bucket");

// S3 with explicit configuration (supports S3-compatible services like MinIO, LocalStack)
let config = CloudStorageConfig::S3 {
    bucket: "my-bucket".to_string(),
    region: Some("us-east-1".to_string()),
    endpoint: Some("http://localhost:4566".to_string()),  // For LocalStack
    access_key_id: Some("key".to_string()),
    secret_access_key: Some("secret".to_string()),
    session_token: None,
    virtual_hosted_style: false,
};

// GCS from environment (GOOGLE_APPLICATION_CREDENTIALS)
let config = CloudStorageConfig::gcs_from_env("my-bucket");

// GCS with service account
let config = CloudStorageConfig::Gcs {
    bucket: "my-bucket".to_string(),
    service_account_path: Some("/path/to/service-account.json".to_string()),
    service_account_key: None,
};

// Azure from environment (AZURE_STORAGE_ACCOUNT, AZURE_STORAGE_ACCESS_KEY)
let config = CloudStorageConfig::azure_from_env("my-container");

// Azure with explicit configuration
let config = CloudStorageConfig::Azure {
    container: "my-container".to_string(),
    account: "mystorageaccount".to_string(),
    access_key: Some("key".to_string()),
    sas_token: None,
};

let db = Uni::open(&config.to_url())
    .cloud_config(config)
    .build().await?;
```

### Synchronous API

```rust
use uni_db::UniSync;

let db = UniSync::in_memory()?;
db.execute("CREATE (:Person {name: 'Alice'})")?;
let results = db.query("MATCH (n:Person) RETURN n.name")?;
```

---

## Schema Definition

### Data Types

```rust
use uni_db::DataType;

DataType::String
DataType::Int32
DataType::Int64
DataType::Float32
DataType::Float64
DataType::Bool
DataType::Timestamp    // Unix timestamp
DataType::Date         // Calendar date
DataType::Time         // Time of day
DataType::DateTime     // Date + time
DataType::Duration     // Time duration
DataType::Json         // JSON object
DataType::Vector { dimensions: 768 }  // Vector embedding
DataType::List(Box::new(DataType::String))  // List of strings
DataType::Map(Box::new(DataType::String), Box::new(DataType::Int64))  // Map
```

### Defining Labels and Edge Types

```rust
db.schema()
    // Vertex label
    .label("Person")
    .property("name", DataType::String)           // Required
    .property_nullable("email", DataType::String) // Optional
    .property("age", DataType::Int32)
    .done()

    // Document label (flexible JSON properties)
    .label("Article")
    .property("title", DataType::String)
    .document()  // Allows arbitrary JSON properties
    .done()

    // Label with vector embedding
    .label("Document")
    .property("content", DataType::String)
    .vector("embedding", 768)  // 768-dimensional vector
    .done()

    // Edge type with properties
    .edge_type("KNOWS", &["Person"], &["Person"])
    .property("since", DataType::Int32)
    .property("weight", DataType::Float64)
    .done()

    // Edge type between multiple labels
    .edge_type("AUTHORED", &["Person"], &["Article", "Document"])
    .done()

    .apply()
    .await?;
```

### Index Types

```rust
use uni_db::{IndexType, VectorIndexCfg, VectorAlgo, VectorMetric, ScalarType};

// Vector indexes
IndexType::Vector(VectorIndexCfg {
    algorithm: VectorAlgo::Hnsw { m: 16, ef_construction: 200 },
    metric: VectorMetric::Cosine,
})

IndexType::Vector(VectorIndexCfg {
    algorithm: VectorAlgo::IvfPq { partitions: 100, sub_vectors: 8 },
    metric: VectorMetric::L2,
})

IndexType::Vector(VectorIndexCfg {
    algorithm: VectorAlgo::Flat,
    metric: VectorMetric::Dot,
})

// Scalar indexes
IndexType::Scalar(ScalarType::BTree)   // Range queries, STARTS WITH optimization
IndexType::Scalar(ScalarType::Hash)    // Equality lookups
IndexType::Scalar(ScalarType::Bitmap)  // Low-cardinality columns

// Full-text search
IndexType::FullText

// Adding indexes to schema
db.schema()
    .label("Product")
    .property("name", DataType::String)
    .property("price", DataType::Float64)
    .vector("embedding", 512)
    .index("name", IndexType::FullText)
    .index("price", IndexType::Scalar(ScalarType::BTree))
    .index("embedding", IndexType::Vector(VectorIndexCfg {
        algorithm: VectorAlgo::Hnsw { m: 16, ef_construction: 200 },
        metric: VectorMetric::Cosine,
    }))
    .done()
    .apply()
    .await?;
```

---

## Cypher Queries

### Read Queries

```rust
// Simple query
let results = db.query("MATCH (n:Person) RETURN n").await?;

// With WHERE clause
let results = db.query("MATCH (n:Person) WHERE n.age > 25 RETURN n.name").await?;

// Pattern matching with relationships
let results = db.query("
    MATCH (a:Person)-[r:KNOWS]->(b:Person)
    RETURN a.name, b.name, r.since
").await?;

// Variable-length paths
let results = db.query("
    MATCH (a:Person {name: 'Alice'})-[:KNOWS*1..3]->(b:Person)
    RETURN DISTINCT b.name
").await?;

// Aggregations
let results = db.query("
    MATCH (p:Person)-[:PURCHASED]->(o:Order)
    RETURN p.name, count(o) as order_count, sum(o.total) as total_spent
    ORDER BY total_spent DESC
    LIMIT 10
").await?;

// Process results
for row in results.rows() {
    let name: String = row.get("p.name")?;
    let count: i64 = row.get("order_count")?;
    println!("{}: {} orders", name, count);
}
```

### Parametrized Queries

```rust
let results = db.query_with("MATCH (n:Person {name: $name}) RETURN n")
    .param("name", "Alice")
    .fetch_all()
    .await?;

// Multiple parameters
let results = db.query_with("
    MATCH (n:Person)
    WHERE n.age >= $min_age AND n.age <= $max_age
    RETURN n.name, n.age
")
    .param("min_age", 18)
    .param("max_age", 65)
    .timeout(std::time::Duration::from_secs(30))
    .max_memory(1024 * 1024 * 512)  // 512MB limit
    .fetch_all()
    .await?;

// Streaming large results
let mut cursor = db.query_with("MATCH (n:Person) RETURN n")
    .query_cursor()
    .await?;

while let Some(row) = cursor.next().await? {
    // Process row by row
}
```

### Write Queries

```rust
// Create nodes
db.execute("CREATE (:Person {name: 'Alice', age: 30})").await?;

// Create multiple nodes
db.execute("
    CREATE (:Person {name: 'Bob'}),
           (:Person {name: 'Carol'}),
           (:Company {name: 'Acme'})
").await?;

// Create relationships
db.execute("
    MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})
    CREATE (a)-[:KNOWS {since: 2020}]->(b)
").await?;

// MERGE (create if not exists)
db.execute("MERGE (:Person {name: 'Alice'})").await?;

// Update properties
db.execute("
    MATCH (n:Person {name: 'Alice'})
    SET n.age = 31, n.updated_at = datetime()
").await?;

// Delete
db.execute("MATCH (n:Person {name: 'Temp'}) DELETE n").await?;

// Detach delete (delete node and all relationships)
db.execute("MATCH (n:Person {name: 'Alice'}) DETACH DELETE n").await?;

// Remove property
db.execute("MATCH (n:Person) REMOVE n.temporary_field").await?;
```

### Cypher Syntax Reference

```cypher
-- Node patterns
(n)                          -- Any node
(n:Person)                   -- Node with label
(n:Person {name: 'Alice'})   -- Node with properties
(n:Person:Employee)          -- Multiple labels

-- Relationship patterns
-[r]->                       -- Outgoing relationship
<-[r]-                       -- Incoming relationship
-[r]-                        -- Any direction
-[r:KNOWS]->                 -- With type
-[r:KNOWS {since: 2020}]->   -- With properties
-[r:KNOWS|FOLLOWS]->         -- Multiple types (OR)
-[*1..3]->                   -- Variable length (1 to 3 hops)
-[*]->                       -- Any length

-- WHERE clauses
WHERE n.age > 30
WHERE n.name = 'Alice'
WHERE n.name STARTS WITH 'A'
WHERE n.name ENDS WITH 'e'
WHERE n.name CONTAINS 'lic'
WHERE n.name =~ 'A.*'        -- Regex pattern matching
WHERE n.tags IN ['a', 'b']
WHERE n.active IS NOT NULL
WHERE n.age > 20 AND n.age < 40
WHERE n.status = 'active' OR n.vip = true
WHERE NOT n.deleted

-- Aggregations
count(n)
sum(n.value)
avg(n.value)
min(n.value)
max(n.value)
collect(n.name)              -- Collect into list

-- RETURN
RETURN n
RETURN n.name, n.age
RETURN n.name AS person_name
RETURN DISTINCT n.category
RETURN *                     -- All variables

-- ORDER BY, LIMIT, SKIP
ORDER BY n.name ASC
ORDER BY n.age DESC, n.name
LIMIT 10
SKIP 20
SKIP 20 LIMIT 10
```

### Cypher Functions Reference

```cypher
-- Math functions
abs(n.value)                 -- Absolute value
ceil(n.value)                -- Round up
floor(n.value)               -- Round down
round(n.value)               -- Round to nearest integer
sqrt(n.value)                -- Square root
sign(n.value)                -- Sign (-1, 0, or 1)
log(n.value)                 -- Natural logarithm
log10(n.value)               -- Base-10 logarithm
exp(n.value)                 -- e^x
power(base, exp)             -- Exponentiation (also: pow)
sin(n.value), cos(n.value), tan(n.value)  -- Trigonometric

-- String functions
toUpper(s), upper(s)         -- Uppercase
toLower(s), lower(s)         -- Lowercase
trim(s), ltrim(s), rtrim(s)  -- Trim whitespace
reverse(s)                   -- Reverse string
replace(s, search, replace)  -- Replace substring
split(s, delimiter)          -- Split into list
substring(s, start, length)  -- Extract substring
left(s, length)              -- Left characters
right(s, length)             -- Right characters
lpad(s, length, pad)         -- Left pad
rpad(s, length, pad)         -- Right pad

-- Type conversion
toInteger(value), toInt(value)   -- Convert to integer
toFloat(value)                   -- Convert to float
toString(value)                  -- Convert to string
toBoolean(value), toBool(value)  -- Convert to boolean

-- List/Collection functions
size(list)                   -- List/Map/String length
keys(map)                    -- Map keys
head(list)                   -- First element
tail(list)                   -- All but first element
last(list)                   -- Last element
length(path)                 -- Path length (relationship count)
nodes(path)                  -- Nodes in path
relationships(path)          -- Relationships in path
range(start, end)            -- Create range list

-- Null handling
coalesce(a, b, 'default')    -- First non-null value
nullif(a, b)                 -- Return null if a equals b

-- Node/Relationship functions
id(n)                        -- Internal node/edge ID
labels(n)                    -- Node labels
type(r)                      -- Relationship type
properties(n)                -- All properties as map

-- Date/Time
date()                       -- Current date
datetime()                   -- Current datetime
time()                       -- Current time
duration({days: 1, hours: 2})  -- Duration literal
```

---

## Vector Search

### Basic Vector Search

```rust
// Search by vector
let query_vec = vec![0.1, 0.2, 0.3, /* ... 768 dims */];
let matches = db.vector_search("Document", "embedding", &query_vec, 10).await?;

for m in matches {
    println!("VID: {:?}, Distance: {}", m.vid, m.distance);
}
```

### Advanced Vector Search

```rust
let results = db.vector_search_with("Document", "embedding", &query_vec)
    .k(10)                              // Top-k results
    .threshold(0.8)                     // Minimum similarity
    .filter("n.category = 'tech'")      // WHERE filter
    .fetch_nodes()                      // Return full nodes
    .await?;

for (node, distance) in results {
    let title: String = node.get("title")?;
    println!("{}: {}", title, distance);
}
```

### Vector Search via Cypher

```cypher
-- Basic vector search
CALL db.idx.vector.query('Document', 'embedding', $query_vector, 10)
YIELD node, distance
RETURN node.title, distance
ORDER BY distance

-- With filtering
CALL db.idx.vector.query('Document', 'embedding', $query_vector, 10)
YIELD node, distance
WHERE node.category = 'tech'
RETURN node.title, distance
```

### Vector Distance Functions

```cypher
-- Vector similarity (requires vector index)
cosine(v1, v2)               -- Cosine similarity
euclidean(v1, v2)            -- Euclidean (L2) distance
dot(v1, v2)                  -- Dot product (inner product)
```

---

## Graph Algorithms

Uni provides 37+ graph algorithms accessible via Cypher procedures and the Rust API.

### Rust API

```rust
// PageRank
let scores = db.algo()
    .pagerank()
    .labels(&["Person"])
    .edge_types(&["KNOWS"])
    .damping(0.85)
    .max_iterations(20)
    .run()
    .await?;  // Vec<(Vid, f64)>

// Weakly Connected Components
let components = db.algo()
    .wcc()
    .labels(&["Person"])
    .edge_types(&["KNOWS", "FOLLOWS"])
    .run()
    .await?;  // Vec<(Vid, i64)>
```

### Centrality Algorithms

```cypher
CALL algo.pageRank(['Person'], ['KNOWS']) YIELD nodeId, score
CALL algo.betweenness(['Person'], ['KNOWS']) YIELD nodeId, score
CALL algo.closeness(['Person'], ['KNOWS']) YIELD nodeId, score
CALL algo.degreeCentrality(['Person'], ['KNOWS'], 'BOTH') YIELD nodeId, degree
CALL algo.eigenvectorCentrality(['Person'], ['KNOWS']) YIELD nodeId, score
CALL algo.harmonicCentrality(['Person'], ['KNOWS']) YIELD nodeId, score
CALL algo.katzCentrality(['Person'], ['KNOWS']) YIELD nodeId, score
```

### Community Detection

```cypher
CALL algo.wcc(['Person'], ['KNOWS']) YIELD nodeId, componentId
CALL algo.scc(['Person'], ['KNOWS']) YIELD nodeId, componentId
CALL algo.louvain(['Person'], ['KNOWS']) YIELD nodeId, communityId
CALL algo.labelPropagation(['Person'], ['KNOWS']) YIELD nodeId, communityId
```

### Path Finding

```cypher
CALL algo.shortestPath(sourceNode, targetNode, ['KNOWS']) YIELD nodeIds, edgeIds, length
CALL algo.dijkstra(sourceVid, targetVid, ['KNOWS'], 'weight') YIELD path, cost
CALL algo.astar(sourceVid, targetVid, ['KNOWS']) YIELD path, cost
CALL algo.bellmanFord(sourceVid, ['KNOWS'], 'weight') YIELD nodeId, distance
CALL algo.bidirectionalDijkstra(sourceVid, targetVid, ['KNOWS']) YIELD path, cost
CALL algo.kShortestPaths(sourceVid, targetVid, ['KNOWS'], 3) YIELD path, cost
CALL algo.allSimplePaths(sourceVid, targetVid, ['KNOWS'], 5) YIELD path
CALL algo.apsp(['Person'], ['KNOWS']) YIELD source, target, distance  -- All-pairs shortest paths
```

### Structural Analysis

```cypher
CALL algo.triangleCount(['Person'], ['KNOWS']) YIELD count
CALL algo.kcore(['Person'], ['KNOWS'], 3) YIELD nodeId, coreLevel
CALL algo.bridges(['Person'], ['KNOWS']) YIELD source, target
CALL algo.articulationPoints(['Person'], ['KNOWS']) YIELD nodeId
CALL algo.bipartiteCheck(['Person'], ['KNOWS']) YIELD isBipartite, partition
CALL algo.cycleDetection(['Task'], ['DEPENDS_ON']) YIELD hasCycle, cycle
CALL algo.elementaryCircuits(['Person'], ['KNOWS']) YIELD circuit
CALL algo.graphColoring(['Person'], ['KNOWS']) YIELD nodeId, color
```

### Graph Algorithms

```cypher
CALL algo.mst(['Person'], ['KNOWS'], 'weight') YIELD edges, totalWeight
CALL algo.maxMatching(['Person'], ['KNOWS']) YIELD node1, node2
CALL algo.maxFlow(sourceVid, sinkVid, ['PIPE'], 'capacity') YIELD maxFlow
CALL algo.graphMetrics(['Person'], ['KNOWS']) YIELD diameter, radius, center
CALL algo.maximalCliques(['Person'], ['KNOWS']) YIELD clique
```

### Similarity

```cypher
CALL algo.nodeSimilarity(['Person'], ['KNOWS']) YIELD node1, node2, similarity
```

### Traversal

```cypher
CALL algo.randomWalk(startVid, 10, ['KNOWS']) YIELD path
CALL algo.topologicalSort(['Task'], ['DEPENDS_ON']) YIELD nodeId, order
```

---

## Transactions

### Basic Transactions

```rust
// Closure-based (auto-commit on success, rollback on error)
db.transaction(|tx| Box::pin(async move {
    tx.execute("CREATE (:Account {id: 1, balance: 100})").await?;
    tx.execute("CREATE (:Account {id: 2, balance: 50})").await?;
    Ok(())
})).await?;

// Manual transaction control
let tx = db.begin().await?;
tx.execute("MATCH (a:Account {id: 1}) SET a.balance = a.balance - 10").await?;
tx.execute("MATCH (a:Account {id: 2}) SET a.balance = a.balance + 10").await?;
tx.commit().await?;

// Query within transaction
let tx = db.begin().await?;
let results = tx.query("MATCH (a:Account) RETURN a.balance").await?;
tx.commit().await?;

// Rollback
let tx = db.begin().await?;
tx.execute("CREATE (:Temp {data: 'test'})").await?;
tx.rollback().await?;  // Changes discarded
```

---

## Bulk Operations

```rust
// Bulk insert vertices
let properties = vec![
    [("name", "Alice"), ("age", 30)].into(),
    [("name", "Bob"), ("age", 25)].into(),
    [("name", "Carol"), ("age", 35)].into(),
];
let vids = db.bulk_insert_vertices("Person", properties).await?;

// Bulk insert edges
let edges = vec![
    (vids[0], vids[1], [("since", 2020)].into()),
    (vids[1], vids[2], [("since", 2021)].into()),
];
db.bulk_insert_edges("KNOWS", edges).await?;
```

---

## Snapshots and Time-Travel

```rust
// Create snapshot
let snapshot_id = db.create_snapshot("v1.0").await?;

// List snapshots
let snapshots = db.list_snapshots().await?;
for snap in snapshots {
    println!("{}: {} ({})", snap.id, snap.name, snap.created_at);
}

// Time-travel query (read-only view at snapshot)
let historical = Uni::open("./my_graph")
    .at_snapshot(&snapshot_id)
    .build()
    .await?;
let old_data = historical.query("MATCH (n) RETURN count(n)").await?;

// Restore snapshot
db.restore_snapshot(&snapshot_id).await?;
```

---

## Persistence and Maintenance

```rust
// Flush L0 buffer to storage (required before vector search on new data)
db.flush().await?;

// Manual compaction
let stats = db.compact_label("Person").await?;
println!("Compacted {} vertices", stats.vertices_compacted);

let stats = db.compact_edge_type("KNOWS").await?;
println!("Compacted {} edges", stats.edges_compacted);

// Wait for background compaction
db.wait_for_compaction().await?;

// Backup (for file-based databases)
db.backup("./backup_path").await?;
```

---

## Configuration

```rust
use uni_db::{UniConfig, CompactionConfig, WriteThrottleConfig, ObjectStoreConfig};
use std::time::Duration;

let config = UniConfig {
    cache_size: 1024 * 1024 * 1024,      // 1GB adjacency cache
    parallelism: 8,                       // Worker threads
    batch_size: 1024,                     // Query batch size
    max_frontier_size: 1_000_000,         // Traversal limit
    auto_flush_threshold: 10_000,         // Mutations before auto-flush
    auto_flush_interval: Some(Duration::from_secs(5)),  // Time-based flush
    auto_flush_min_mutations: 1,          // Min mutations for time-based flush
    wal_enabled: true,                    // Write-ahead logging
    query_timeout: Duration::from_secs(30),
    max_query_memory: 1024 * 1024 * 1024, // 1GB per query
    compaction: CompactionConfig {
        enabled: true,
        max_l1_runs: 4,
        max_l1_size_bytes: 256 * 1024 * 1024,
        max_l1_age: Duration::from_secs(3600),
        check_interval: Duration::from_secs(30),
        worker_threads: 1,
    },
    throttle: WriteThrottleConfig {
        soft_limit: 8,
        hard_limit: 16,
        base_delay: Duration::from_millis(10),
    },
    object_store: ObjectStoreConfig {
        connect_timeout: Duration::from_secs(10),
        read_timeout: Duration::from_secs(30),
        write_timeout: Duration::from_secs(60),
        max_retries: 3,
        retry_backoff_base: Duration::from_millis(100),
        retry_backoff_max: Duration::from_secs(10),
    },
    ..Default::default()
};

let db = Uni::open("./my_graph")
    .config(config)
    .build()
    .await?;
```

### Server Mode Configuration

```rust
use uni_db::{ServerConfig, FileSandboxConfig, DeploymentMode};

// Development server (permissive - NOT for production)
let server_config = ServerConfig::development();

// Production server with security
let server_config = ServerConfig::production(
    vec!["https://myapp.com".to_string()],  // Allowed CORS origins
    "my-secret-api-key".to_string(),        // Required API key
);

// File sandbox for secure file operations (BACKUP, COPY, EXPORT)
let sandbox = FileSandboxConfig::sandboxed(vec![
    PathBuf::from("/var/lib/uni/data"),
    PathBuf::from("/var/lib/uni/backups"),
]);
```

---

## Error Handling

```rust
use uni_db::{Result, UniError};

match db.query("MATCH (n:Person) RETURN n").await {
    Ok(results) => { /* process results */ }
    Err(UniError::Parse { message, line, column, .. }) => {
        eprintln!("Syntax error at {}:{}: {}", line, column, message);
    }
    Err(UniError::Query { message, query }) => {
        eprintln!("Query failed: {} in '{}'", message, query);
    }
    Err(UniError::LabelNotFound { label }) => {
        eprintln!("Label '{}' not defined in schema", label);
    }
    Err(UniError::TransactionConflict { message }) => {
        eprintln!("Transaction conflict: {}", message);
    }
    Err(e) => {
        eprintln!("Error: {}", e);
    }
}
```

---

## Query Optimization

### Index-Aware Predicate Pushdown

Uni automatically optimizes queries using available indexes in order of selectivity:

1. **UID lookup** (`_uid = 'xxx'`) - O(1) hash lookup
2. **JSON FTS** (`column CONTAINS 'term'`) - BM25 full-text search
3. **JsonPath index** (`prop = 'value'` for indexed paths)
4. **BTree prefix scan** (`STARTS WITH 'prefix'`) - Range scan on BTree indexes
5. **Lance scan filter** - Columnar filter pushdown
6. **Residual** - Application-level evaluation

### STARTS WITH Optimization

When a property has a BTree index, `STARTS WITH` predicates are automatically converted to efficient range scans:

```cypher
-- With BTree index on name, this becomes a range scan:
-- name >= 'John' AND name < 'Joho'
MATCH (n:Person) WHERE n.name STARTS WITH 'John' RETURN n
```

### Regex Pattern Matching

```cypher
-- Match names starting with A followed by any characters
MATCH (n:Person) WHERE n.name =~ 'A.*' RETURN n.name

-- Match email patterns
MATCH (n:Person) WHERE n.email =~ '.*@example\\.com' RETURN n
```

---

## Common Patterns

### Knowledge Graph

```rust
db.schema()
    .label("Entity")
    .property("name", DataType::String)
    .property("type", DataType::String)
    .vector("embedding", 768)
    .done()
    .edge_type("RELATED_TO", &["Entity"], &["Entity"])
    .property("relation", DataType::String)
    .property("confidence", DataType::Float64)
    .done()
    .apply()
    .await?;

// Add entities and relationships
db.execute("CREATE (:Entity {name: 'Albert Einstein', type: 'Person'})").await?;
db.execute("CREATE (:Entity {name: 'Theory of Relativity', type: 'Theory'})").await?;
db.execute("
    MATCH (a:Entity {name: 'Albert Einstein'}), (b:Entity {name: 'Theory of Relativity'})
    CREATE (a)-[:RELATED_TO {relation: 'developed', confidence: 1.0}]->(b)
").await?;
```

### Social Network

```rust
db.schema()
    .label("User")
    .property("username", DataType::String)
    .property("joined", DataType::DateTime)
    .done()
    .label("Post")
    .property("content", DataType::String)
    .property("created", DataType::DateTime)
    .done()
    .edge_type("FOLLOWS", &["User"], &["User"])
    .edge_type("POSTED", &["User"], &["Post"])
    .edge_type("LIKES", &["User"], &["Post"])
    .apply()
    .await?;

// Find friends of friends
let results = db.query("
    MATCH (me:User {username: $user})-[:FOLLOWS]->()-[:FOLLOWS]->(fof:User)
    WHERE NOT (me)-[:FOLLOWS]->(fof) AND me <> fof
    RETURN DISTINCT fof.username
    LIMIT 10
")
    .param("user", "alice")
    .fetch_all()
    .await?;
```

### RAG (Retrieval-Augmented Generation)

```rust
db.schema()
    .label("Document")
    .property("content", DataType::String)
    .property("source", DataType::String)
    .vector("embedding", 1536)
    .index("embedding", IndexType::Vector(VectorIndexCfg {
        algorithm: VectorAlgo::Hnsw { m: 16, ef_construction: 200 },
        metric: VectorMetric::Cosine,
    }))
    .done()
    .apply()
    .await?;

// Store document with embedding
let embedding = embed_text("Document content here...");  // Your embedding function
db.execute(&format!(
    "CREATE (:Document {{content: $content, source: $source, embedding: {}}})",
    format!("{:?}", embedding)
))
    .param("content", "Document content here...")
    .param("source", "manual.pdf")
    .fetch_all()
    .await?;

db.flush().await?;  // Required before vector search

// Retrieve similar documents
let query_embedding = embed_text("user question");
let docs = db.vector_search_with("Document", "embedding", &query_embedding)
    .k(5)
    .threshold(0.7)
    .fetch_nodes()
    .await?;
```

### Fraud Detection

```rust
db.schema()
    .label("Account")
    .property("id", DataType::String)
    .property("created_at", DataType::DateTime)
    .done()
    .label("Device")
    .property("fingerprint", DataType::String)
    .done()
    .edge_type("LOGGED_IN_FROM", &["Account"], &["Device"])
    .edge_type("TRANSFERRED_TO", &["Account"], &["Account"])
    .property("amount", DataType::Float64)
    .property("timestamp", DataType::DateTime)
    .done()
    .apply()
    .await?;

// Find accounts sharing devices (potential fraud ring)
let results = db.query("
    MATCH (a1:Account)-[:LOGGED_IN_FROM]->(d:Device)<-[:LOGGED_IN_FROM]-(a2:Account)
    WHERE a1 <> a2
    RETURN a1.id, a2.id, d.fingerprint
").await?;

// Detect circular money transfers
let results = db.query("
    CALL algo.cycleDetection(['Account'], ['TRANSFERRED_TO'])
    YIELD hasCycle, cycle
    RETURN hasCycle, cycle
").await?;
```

### Supply Chain

```rust
db.schema()
    .label("Product")
    .property("sku", DataType::String)
    .property("name", DataType::String)
    .done()
    .label("Supplier")
    .property("name", DataType::String)
    .property("country", DataType::String)
    .done()
    .label("Warehouse")
    .property("location", DataType::String)
    .property("capacity", DataType::Int64)
    .done()
    .edge_type("SUPPLIES", &["Supplier"], &["Product"])
    .property("lead_time_days", DataType::Int32)
    .property("cost", DataType::Float64)
    .done()
    .edge_type("STORED_AT", &["Product"], &["Warehouse"])
    .property("quantity", DataType::Int64)
    .done()
    .apply()
    .await?;

// Find supply chain path
let results = db.query("
    MATCH path = (s:Supplier)-[:SUPPLIES*1..5]->(p:Product)-[:STORED_AT]->(w:Warehouse)
    WHERE p.sku = $sku
    RETURN s.name, w.location, length(path)
")
    .param("sku", "ABC123")
    .fetch_all()
    .await?;
```

---

## Python Bindings

Uni provides Python bindings via PyO3 for use in Python applications and Jupyter notebooks.

```python
import uni_db

# Create in-memory database
db = uni_db.Database.in_memory()

# Define schema
db.schema() \
    .label("Person") \
    .property("name", uni_db.DataType.String) \
    .property("age", uni_db.DataType.Int32) \
    .done() \
    .edge_type("KNOWS", ["Person"], ["Person"]) \
    .apply()

# Execute queries
db.execute("CREATE (:Person {name: 'Alice', age: 30})")
db.execute("CREATE (:Person {name: 'Bob', age: 25})")

# Query data
results = db.query("MATCH (p:Person) RETURN p.name, p.age ORDER BY p.age")
for row in results:
    print(f"{row['p.name']}: {row['p.age']}")

# Vector search
query_vec = [0.1, 0.2, ...]  # Your embedding
matches = db.vector_search("Document", "embedding", query_vec, k=10)

# Flush and close
db.flush()
```

---

## Jupyter Notebook Examples

Uni includes Jupyter notebooks demonstrating common use cases:

| Notebook | Description |
|----------|-------------|
| `supply_chain.ipynb` | BOM explosion, cost rollup, supplier analysis |
| `recommendation.ipynb` | Collaborative filtering, vector similarity |
| `rag.ipynb` | Retrieval-Augmented Generation with knowledge graphs |
| `fraud_detection.ipynb` | Cycle detection, shared device analysis |
| `sales_analytics.ipynb` | Graph traversal with columnar aggregations |

Available for both Rust (evcxr_jupyter) and Python.

---

## Architecture Notes

- **Storage**: Lance columnar format with CSR adjacency for fast traversal
- **Concurrency**: Single-writer, multi-reader with snapshot isolation
- **WAL**: Write-ahead logging for durability
- **Indexes**: Lance-native vector indexes (HNSW, IVF-PQ, Flat) and scalar indexes (BTree, Hash, Bitmap)
- **Compaction**: LSM-style (L0 memory -> L1 sorted runs -> L2 merged)
- **Object Store**: Supports local filesystem, S3, GCS, Azure via object_store crate
- **Hybrid Storage**: Local WAL + remote object storage for fast writes with durable storage

---

## Further Reading

- Design document: `DESIGN.md`
- Algorithm catalog: `ALGORITHM_GAPS.md`
- API recommendations: `API_RECOMMENDATIONS.md`
